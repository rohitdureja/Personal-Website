<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="http://www.rohitdureja.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.rohitdureja.com/" rel="alternate" type="text/html" /><updated>2018-12-22T22:49:52-06:00</updated><id>http://www.rohitdureja.com/</id><title type="html">Rohit Dureja</title><subtitle>Personal webpage of Rohit Dureja.</subtitle><entry><title type="html">Interpolants and Relevance</title><link href="http://www.rohitdureja.com/notes/2017/06/29/interpolants-and-relevance" rel="alternate" type="text/html" title="Interpolants and Relevance" /><published>2017-06-29T00:00:00-05:00</published><updated>2017-06-29T00:00:00-05:00</updated><id>http://www.rohitdureja.com/notes/2017/06/29/interpolants-and-relevance</id><content type="html" xml:base="http://www.rohitdureja.com/notes/2017/06/29/interpolants-and-relevance">&lt;p&gt;For a pair of inconsistent formulas &lt;script type=&quot;math/tex&quot;&gt;(A, B)&lt;/script&gt;, i.e., &lt;script type=&quot;math/tex&quot;&gt;A \wedge B \equiv \bot&lt;/script&gt; or &lt;strong&gt;unsatisfiable&lt;/strong&gt;, the &lt;strong&gt;Craig Interpolant&lt;/strong&gt; &lt;a href=&quot;#Cra57&quot;&gt;[1]&lt;/a&gt; for &lt;script type=&quot;math/tex&quot;&gt;(A, B)&lt;/script&gt; is a formula &lt;script type=&quot;math/tex&quot;&gt;\mathcal{I}&lt;/script&gt; such that&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;A \to \mathcal{I}&lt;/script&gt;,&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;\mathcal{I} \wedge B \equiv \bot&lt;/script&gt;, and&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;\mathcal{I}&lt;/script&gt; contains variables common to &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The interpolant can be viewed as the part of &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; that is sufficient, or &lt;strong&gt;relevant&lt;/strong&gt;, to contradict &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. Modern SAT solvers produce a &lt;em&gt;proof of unsatisfiability&lt;/em&gt;, or resolution proof, if the checked formula is unsatisfiable. &lt;!-- break --&gt; An interpolant can be extracted in linear time &lt;a href=&quot;#Pud97&quot;&gt;[2]&lt;/a&gt; from a proof of unsatisfiability. The chief advantage of deriving interpolants from proofs is that they capture facts which the SAT solver derived about &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; in showing that &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; is inconsistent with &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. Therefore, assuming that the prover ignores irrelevant facts and focuses on real ones, interpolation can be thought of as a way of filtering out irrelevant information from &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; &lt;a href=&quot;#McM05&quot;&gt;[3]&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;interpolants-from-proofs&quot;&gt;Interpolants from Proofs&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Preliminaries.&lt;/strong&gt; A &lt;em&gt;literal&lt;/em&gt; is a Boolean variable or its negation. A &lt;em&gt;clause&lt;/em&gt; is a disjunction of zero or more literals. A clause set is &lt;em&gt;satisfiable&lt;/em&gt; if there exists a truth assignment to the Boolean variables that makes all clauses in the set true. Given two clauses &lt;script type=&quot;math/tex&quot;&gt;c_1 = a \vee b&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;c_2 = \neg a \vee c&lt;/script&gt;, the &lt;em&gt;resolvent&lt;/em&gt; of &lt;script type=&quot;math/tex&quot;&gt;c_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;c_2&lt;/script&gt; is the clause &lt;script type=&quot;math/tex&quot;&gt;b \vee c&lt;/script&gt;, assuming &lt;script type=&quot;math/tex&quot;&gt;b \vee c&lt;/script&gt; is non-tautological, and &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is the &lt;em&gt;pivot variable&lt;/em&gt;. Similarly, &lt;script type=&quot;math/tex&quot;&gt;a \vee b&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\neg a \vee \neg c&lt;/script&gt; have resolvent &lt;script type=&quot;math/tex&quot;&gt;b \vee \neg c&lt;/script&gt;, while &lt;script type=&quot;math/tex&quot;&gt;a \vee b&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\neg a \vee \neg b&lt;/script&gt; have no resolvent, since &lt;script type=&quot;math/tex&quot;&gt;b \vee \neg b&lt;/script&gt; is tautological. Therefore, the resolvent of clauses &lt;script type=&quot;math/tex&quot;&gt;c_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;c_2&lt;/script&gt; is a clause that is implied by &lt;script type=&quot;math/tex&quot;&gt;c_1 \wedge c_2&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;\exists v (c_1 \wedge c_2)&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; is the pivot variable.&lt;/p&gt;

&lt;h3 id=&quot;proof-of-unsatisfiability&quot;&gt;Proof of Unsatisfiability&lt;/h3&gt;

&lt;p&gt;A proof of unsatisfiability &lt;script type=&quot;math/tex&quot;&gt;\Pi&lt;/script&gt; for a set of clauses &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; is a directed acyclic graph &lt;script type=&quot;math/tex&quot;&gt;(V, E)&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; is a set of clauses, and&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;for every vertex &lt;script type=&quot;math/tex&quot;&gt;c \in V&lt;/script&gt;, either
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;c \in C&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; is a root, or&lt;/li&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; has exactly two predecessors, &lt;script type=&quot;math/tex&quot;&gt;c_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;c_2&lt;/script&gt;, such that &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; is their resolvent, and&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;the empty clause is an unique leaf.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If a proof on unsatisfiability exists for a set of clauses, then the clause set is unsatisfiable. In the satisfiable case, a SAT solver produces a satisfying assignment, whereas in the unsatisfiable case, it can produce a proof on unsatisfiability. The &lt;a href=&quot;https://en.wikipedia.org/wiki/Resolution_(logic)&quot;&gt;Wikipedia article on Resolution&lt;/a&gt;, along with &lt;a href=&quot;http://intrologic.stanford.edu/notes/chapter_05.html&quot;&gt;Propositional Resolution&lt;/a&gt;, is a good starting point on the use of resolution to check satisfiability of a set of clauses.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt; Consider clause set &lt;script type=&quot;math/tex&quot;&gt;C = \{c_1, c_2, c_3, c_4\}&lt;/script&gt;, such that &lt;script type=&quot;math/tex&quot;&gt;c_1 = (p \vee q)&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;c_2 = (\neg p \vee r)&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;c_3 = (p \vee \neg q)&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;c_4 = (\neg p \vee \neg r)&lt;/script&gt;. The proof of unsatisfiability graph for &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; is shown in Figure 1. &lt;script type=&quot;math/tex&quot;&gt;r_{13}&lt;/script&gt; is resolvent of clauses &lt;script type=&quot;math/tex&quot;&gt;c_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;c_3&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;r_{24}&lt;/script&gt; is resolvent of &lt;script type=&quot;math/tex&quot;&gt;c_2&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;c_4&lt;/script&gt;. Resolvent clauses &lt;script type=&quot;math/tex&quot;&gt;r_{13}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;r_{24}&lt;/script&gt; are resolve to the empty leaf clause. Therefore, &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; is unsatisfiable.&lt;/p&gt;

&lt;figure class=&quot;figure&quot;&gt;
  &lt;img src=&quot;/images/posts/resolution_graph.png&quot; class=&quot;figure-img img-fluid rounded center-block&quot; style=&quot;width:350px; align: center;&quot; /&gt;

  &lt;figcaption&gt;
    &lt;p&gt;Figure 1: A proof of unsatisfiability graph for clauses &lt;script type=&quot;math/tex&quot;&gt;(p \vee q)&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;(\neg p \vee r)&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;(p \vee \neg q)&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;(\neg p \vee \neg r)&lt;/script&gt;.&lt;/p&gt;

  &lt;/figcaption&gt;

&lt;/figure&gt;

&lt;h3 id=&quot;algorithm-to-find-interpolants&quot;&gt;Algorithm to find Interpolants&lt;/h3&gt;

&lt;p&gt;Suppose we are given a pair of clause set &lt;script type=&quot;math/tex&quot;&gt;(A, B)&lt;/script&gt; and a proof of unsatisfiability &lt;script type=&quot;math/tex&quot;&gt;\Pi&lt;/script&gt; of &lt;script type=&quot;math/tex&quot;&gt;A \wedge B&lt;/script&gt;. Some terminology:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Global variable&lt;/strong&gt;: a variable appearing in both &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Local variable&lt;/strong&gt;: a variable appearing only in &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Similarly, a literal is global or local to &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; depending on the variable it contains. Given a clause &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;g(c)&lt;/script&gt; denotes the disjunction of the global literals in &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;l(c)&lt;/script&gt; denotes the disjunction of local literals in &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; with respect to &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt; We have two clauses, &lt;script type=&quot;math/tex&quot;&gt;c_1 = (a \vee \neg b \vee c)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;c_2 = (\neg a \vee b \vee \neg d)&lt;/script&gt;, and suppose &lt;script type=&quot;math/tex&quot;&gt;A = \{c_1\}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B = \{c_2\}&lt;/script&gt;. Then&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;g(c_1) = (a \vee \neg b)&lt;/script&gt;,&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;l(c_1) = (c)&lt;/script&gt;,&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;g(c_2) = (\neg a \vee b)&lt;/script&gt;, and&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;l(c_2) = (\bot)&lt;/script&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Algorithm:&lt;/strong&gt; The description of the algorithm to find interpolant from proofs is based on &lt;a href=&quot;#McM03&quot;&gt;[4]&lt;/a&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;(A, B)&lt;/script&gt; be a pair of set clauses and &lt;script type=&quot;math/tex&quot;&gt;\Pi = (V, E)&lt;/script&gt; be the proof of unsatisfiability graph for inconsistency of &lt;script type=&quot;math/tex&quot;&gt;A \wedge B&lt;/script&gt;. For every vertex &lt;script type=&quot;math/tex&quot;&gt;c \in V&lt;/script&gt;, we compute a boolean formula &lt;script type=&quot;math/tex&quot;&gt;p(c)&lt;/script&gt; as follows.&lt;/p&gt;

&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;&lt;span&gt;if c is root, i.e. c ∈ V then&lt;/span&gt;
&lt;span&gt;  if c ∈ A then&lt;/span&gt;
&lt;span&gt;    p(c) = g(c)&lt;/span&gt;
&lt;span&gt;  else&lt;/span&gt;
&lt;span&gt;    p(c) = True&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;
&lt;span&gt;  a, b = predecessors of c&lt;/span&gt;
&lt;span&gt;  v = pivot variable of a, b&lt;/span&gt;
&lt;span&gt;  if v is local to A then&lt;/span&gt;
&lt;span&gt;    p(c) = p(a) ∨ p(b)&lt;/span&gt;
&lt;span&gt;  else&lt;/span&gt;
&lt;span&gt;    p(c) = p(a) ∧ p(b)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The interpolant of &lt;script type=&quot;math/tex&quot;&gt;(A, B)&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;p(c = \bot)&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; is leaf vertex in &lt;script type=&quot;math/tex&quot;&gt;\Pi&lt;/script&gt;, or &lt;script type=&quot;math/tex&quot;&gt;p(\bot)&lt;/script&gt;. The interpolant for &lt;script type=&quot;math/tex&quot;&gt;(A, B)&lt;/script&gt; is not unique and depends on the proof of unsatisfiability &lt;script type=&quot;math/tex&quot;&gt;\Pi&lt;/script&gt;. Therefore, we often denote interpolant for &lt;script type=&quot;math/tex&quot;&gt;(A, B)&lt;/script&gt; with respect to &lt;script type=&quot;math/tex&quot;&gt;\Pi&lt;/script&gt; as &lt;script type=&quot;math/tex&quot;&gt;ITP(\Pi, A, B)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Complexity:&lt;/strong&gt; Let &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; be the number of vertices in &lt;script type=&quot;math/tex&quot;&gt;\Pi&lt;/script&gt;, i.e., &lt;script type=&quot;math/tex&quot;&gt;N = |V|&lt;/script&gt;, and
&lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt; be the number of literals appearing in
&lt;script type=&quot;math/tex&quot;&gt;\Pi&lt;/script&gt;, i.e.,
&lt;script type=&quot;math/tex&quot;&gt;L = \Sigma_{c \in V} |c|&lt;/script&gt;. It the worst case, lines 2–5 repeat $N$ times, and lines 7–8 repeat &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt; since every literal in &lt;script type=&quot;math/tex&quot;&gt;\Pi&lt;/script&gt; can be a pivot variable. Therefore, the formula &lt;script type=&quot;math/tex&quot;&gt;ITP(\Pi, A, B)&lt;/script&gt; can be computed in &lt;script type=&quot;math/tex&quot;&gt;O(N + L)&lt;/script&gt; time, i.e., linear in the size of &lt;script type=&quot;math/tex&quot;&gt;\Pi&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 4:&lt;/em&gt; Consider the clause set &lt;script type=&quot;math/tex&quot;&gt;C = \{c_1, c_2, c_3, c_4\}&lt;/script&gt;, such that &lt;script type=&quot;math/tex&quot;&gt;c_1 = (p \vee q)&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;c_2 = (\neg p \vee r)&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;c_3 = (p \vee \neg q)&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;c_4 = (\neg p \vee \neg r)&lt;/script&gt;, from Example 1. The proof of unsatisfiability for &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; is shown in Figure 1. Let &lt;script type=&quot;math/tex&quot;&gt;A = \{c_1, c_3\}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B = \{c_2, c_4\}&lt;/script&gt;. We know that &lt;script type=&quot;math/tex&quot;&gt;A \wedge B&lt;/script&gt; is unsatisfiable. we first find the global and local literals for each clause in &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;: &lt;script type=&quot;math/tex&quot;&gt;g(c_1) = (p)&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;l(c_1) = q&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;g(c_2) = \neg p&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;l(c_2) = \neg q&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;g(c_3) = p&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;l(c_3) = \bot&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;g(c_4) = \neg p&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;l(c_4) = \bot&lt;/script&gt;. Figure 2 shows the &lt;script type=&quot;math/tex&quot;&gt;p(c)&lt;/script&gt; formulas computed using the above algorithm for every &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; vertex of Figure 1.&lt;/p&gt;

&lt;figure class=&quot;figure&quot;&gt;
  &lt;img src=&quot;/images/posts/interpolation_alg.png&quot; class=&quot;figure-img img-fluid rounded center-block&quot; style=&quot;width:350px; align: center;&quot; /&gt;

  &lt;figcaption&gt;
    &lt;p&gt;Figure 2: Intermediate &lt;script type=&quot;math/tex&quot;&gt;p(c)&lt;/script&gt; formulas for every vertex &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; in the proof of unsatisfiability graph of Figure 1.&lt;/p&gt;

  &lt;/figcaption&gt;

&lt;/figure&gt;

&lt;p&gt;For the leaf vertex &lt;script type=&quot;math/tex&quot;&gt;l&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;p(l) = p&lt;/script&gt;. Therefore, &lt;script type=&quot;math/tex&quot;&gt;ITP(\Pi, A, B) = p&lt;/script&gt;. It can be verified that &lt;script type=&quot;math/tex&quot;&gt;\mathcal{I} = p&lt;/script&gt; is the interpolant of clause sets &lt;script type=&quot;math/tex&quot;&gt;(A, B)&lt;/script&gt; since &lt;script type=&quot;math/tex&quot;&gt;A \to \mathcal{I}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\mathcal{I} \wedge B \equiv \bot&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;\mathcal{I}&lt;/script&gt; contains variables common to both &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;.&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;references&quot;&gt;References&lt;/h4&gt;

&lt;ol class=&quot;bibliography&quot;&gt;&lt;li&gt;&lt;span id=&quot;McM05&quot;&gt;K L McMillan. 2005. Applications of Craig Interpolants in Model Checking. In &lt;i&gt;11th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS)&lt;/i&gt;, 1–12.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;McM03&quot;&gt;K L McMillan. 2003. Interpolation and SAT-Based Model Checking. In &lt;i&gt;15th International Conference on Computer Aided Verification (CAV)&lt;/i&gt;, 1–13.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;Pud97&quot;&gt;Pavel Pudlák. 1997. Lower bounds for resolution and cutting plane proofs and monotone computations. &lt;i&gt;The Journal of Symbolic Logic&lt;/i&gt; 62, 3 (1997), 981–998.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span id=&quot;Cra57&quot;&gt;William Craig. 1957. Linear reasoning. A new form of the Herbrand-Gentzen theorem. &lt;i&gt;The Journal of Symbolic Logic&lt;/i&gt; 22, 3 (1957), 250–268.&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;</content><author><name>Rohit Dureja</name></author><category term="logic" /><category term="interpolants" /><summary type="html">For a pair of inconsistent formulas , i.e., or unsatisfiable, the Craig Interpolant [1] for is a formula such that , , and contains variables common to and . The interpolant can be viewed as the part of that is sufficient, or relevant, to contradict . Modern SAT solvers produce a proof of unsatisfiability, or resolution proof, if the checked formula is unsatisfiable.</summary></entry></feed>